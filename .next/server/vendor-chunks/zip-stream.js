/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zip-stream";
exports.ids = ["vendor-chunks/zip-stream"];
exports.modules = {

/***/ "(rsc)/./node_modules/zip-stream/index.js":
/*!******************************************!*\
  !*** ./node_modules/zip-stream/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * ZipStream\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}\n * @copyright (c) 2014 Chris Talkington, contributors.\n */\nvar inherits = (__webpack_require__(/*! util */ \"util\").inherits);\n\nvar ZipArchiveOutputStream = (__webpack_require__(/*! compress-commons */ \"(rsc)/./node_modules/compress-commons/lib/compress-commons.js\").ZipArchiveOutputStream);\nvar ZipArchiveEntry = (__webpack_require__(/*! compress-commons */ \"(rsc)/./node_modules/compress-commons/lib/compress-commons.js\").ZipArchiveEntry);\n\nvar util = __webpack_require__(/*! archiver-utils */ \"(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/index.js\");\n\n/**\n * @constructor\n * @extends external:ZipArchiveOutputStream\n * @param {Object} [options]\n * @param {String} [options.comment] Sets the zip archive comment.\n * @param {Boolean} [options.forceLocalTime=false] Forces the archive to contain local file times instead of UTC.\n * @param {Boolean} [options.forceZip64=false] Forces the archive to contain ZIP64 headers.\n * @param {Boolean} [options.store=false] Sets the compression method to STORE.\n * @param {Object} [options.zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}\n * to control compression.\n */\nvar ZipStream = module.exports = function(options) {\n  if (!(this instanceof ZipStream)) {\n    return new ZipStream(options);\n  }\n\n  options = this.options = options || {};\n  options.zlib = options.zlib || {};\n\n  ZipArchiveOutputStream.call(this, options);\n\n  if (typeof options.level === 'number' && options.level >= 0) {\n    options.zlib.level = options.level;\n    delete options.level;\n  }\n\n  if (!options.forceZip64 && typeof options.zlib.level === 'number' && options.zlib.level === 0) {\n    options.store = true;\n  }\n\n  options.namePrependSlash = options.namePrependSlash || false;\n\n  if (options.comment && options.comment.length > 0) {\n    this.setComment(options.comment);\n  }\n};\n\ninherits(ZipStream, ZipArchiveOutputStream);\n\n/**\n * Normalizes entry data with fallbacks for key properties.\n *\n * @private\n * @param  {Object} data\n * @return {Object}\n */\nZipStream.prototype._normalizeFileData = function(data) {\n  data = util.defaults(data, {\n    type: 'file',\n    name: null,\n    namePrependSlash: this.options.namePrependSlash,\n    linkname: null,\n    date: null,\n    mode: null,\n    store: this.options.store,\n    comment: ''\n  });\n\n  var isDir = data.type === 'directory';\n  var isSymlink = data.type === 'symlink';\n\n  if (data.name) {\n    data.name = util.sanitizePath(data.name);\n\n    if (!isSymlink && data.name.slice(-1) === '/') {\n      isDir = true;\n      data.type = 'directory';\n    } else if (isDir) {\n      data.name += '/';\n    }\n  }\n\n  if (isDir || isSymlink) {\n    data.store = true;\n  }\n\n  data.date = util.dateify(data.date);\n\n  return data;\n};\n\n/**\n * Appends an entry given an input source (text string, buffer, or stream).\n *\n * @param  {(Buffer|Stream|String)} source The input source.\n * @param  {Object} data\n * @param  {String} data.name Sets the entry name including internal path.\n * @param  {String} [data.comment] Sets the entry comment.\n * @param  {(String|Date)} [data.date=NOW()] Sets the entry date.\n * @param  {Number} [data.mode=D:0755/F:0644] Sets the entry permissions.\n * @param  {Boolean} [data.store=options.store] Sets the compression method to STORE.\n * @param  {String} [data.type=file] Sets the entry type. Defaults to `directory`\n * if name ends with trailing slash.\n * @param  {Function} callback\n * @return this\n */\nZipStream.prototype.entry = function(source, data, callback) {\n  if (typeof callback !== 'function') {\n    callback = this._emitErrorCallback.bind(this);\n  }\n\n  data = this._normalizeFileData(data);\n\n  if (data.type !== 'file' && data.type !== 'directory' && data.type !== 'symlink') {\n    callback(new Error(data.type + ' entries not currently supported'));\n    return;\n  }\n\n  if (typeof data.name !== 'string' || data.name.length === 0) {\n    callback(new Error('entry name must be a non-empty string value'));\n    return;\n  }\n\n  if (data.type === 'symlink' && typeof data.linkname !== 'string') {\n    callback(new Error('entry linkname must be a non-empty string value when type equals symlink'));\n    return;\n  }\n\n  var entry = new ZipArchiveEntry(data.name);\n  entry.setTime(data.date, this.options.forceLocalTime);\n\n  if (data.namePrependSlash) {\n    entry.setName(data.name, true);\n  }\n\n  if (data.store) {\n    entry.setMethod(0);\n  }\n\n  if (data.comment.length > 0) {\n    entry.setComment(data.comment);\n  }\n\n  if (data.type === 'symlink' && typeof data.mode !== 'number') {\n    data.mode = 40960; // 0120000\n  }\n\n  if (typeof data.mode === 'number') {\n    if (data.type === 'symlink') {\n      data.mode |= 40960;\n    }\n\n    entry.setUnixMode(data.mode);\n  }\n\n  if (data.type === 'symlink' && typeof data.linkname === 'string') {\n    source = Buffer.from(data.linkname);\n  }\n\n  return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);\n};\n\n/**\n * Finalizes the instance and prevents further appending to the archive\n * structure (queue will continue til drained).\n *\n * @return void\n */\nZipStream.prototype.finalize = function() {\n  this.finish();\n};\n\n/**\n * Returns the current number of bytes written to this stream.\n * @function ZipStream#getBytesWritten\n * @returns {Number}\n */\n\n/**\n * Compress Commons ZipArchiveOutputStream\n * @external ZipArchiveOutputStream\n * @see {@link https://github.com/archiverjs/node-compress-commons}\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvemlwLXN0cmVhbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZSxrREFBd0I7O0FBRXZDLDZCQUE2QixxSUFBa0Q7QUFDL0Usc0JBQXNCLDhIQUEyQzs7QUFFakUsV0FBVyxtQkFBTyxDQUFDLDRGQUFnQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVEsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxlQUFlO0FBQzNCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZCBnb2t1bFxcRG93bmxvYWRzXFxxcm1hbmFnZW1lbnRcXG5vZGVfbW9kdWxlc1xcemlwLXN0cmVhbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBaaXBTdHJlYW1cbiAqXG4gKiBAaWdub3JlXG4gKiBAbGljZW5zZSBbTUlUXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXJjaGl2ZXJqcy9ub2RlLXppcC1zdHJlYW0vYmxvYi9tYXN0ZXIvTElDRU5TRX1cbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTQgQ2hyaXMgVGFsa2luZ3RvbiwgY29udHJpYnV0b3JzLlxuICovXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG5cbnZhciBaaXBBcmNoaXZlT3V0cHV0U3RyZWFtID0gcmVxdWlyZSgnY29tcHJlc3MtY29tbW9ucycpLlppcEFyY2hpdmVPdXRwdXRTdHJlYW07XG52YXIgWmlwQXJjaGl2ZUVudHJ5ID0gcmVxdWlyZSgnY29tcHJlc3MtY29tbW9ucycpLlppcEFyY2hpdmVFbnRyeTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCdhcmNoaXZlci11dGlscycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgZXh0ZXJuYWw6WmlwQXJjaGl2ZU91dHB1dFN0cmVhbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbW1lbnRdIFNldHMgdGhlIHppcCBhcmNoaXZlIGNvbW1lbnQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvcmNlTG9jYWxUaW1lPWZhbHNlXSBGb3JjZXMgdGhlIGFyY2hpdmUgdG8gY29udGFpbiBsb2NhbCBmaWxlIHRpbWVzIGluc3RlYWQgb2YgVVRDLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb3JjZVppcDY0PWZhbHNlXSBGb3JjZXMgdGhlIGFyY2hpdmUgdG8gY29udGFpbiBaSVA2NCBoZWFkZXJzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9yZT1mYWxzZV0gU2V0cyB0aGUgY29tcHJlc3Npb24gbWV0aG9kIHRvIFNUT1JFLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJdIFBhc3NlZCB0byBbemxpYl17QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS96bGliLmh0bWwjemxpYl9jbGFzc19vcHRpb25zfVxuICogdG8gY29udHJvbCBjb21wcmVzc2lvbi5cbiAqL1xudmFyIFppcFN0cmVhbSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgWmlwU3RyZWFtKSkge1xuICAgIHJldHVybiBuZXcgWmlwU3RyZWFtKG9wdGlvbnMpO1xuICB9XG5cbiAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuemxpYiA9IG9wdGlvbnMuemxpYiB8fCB7fTtcblxuICBaaXBBcmNoaXZlT3V0cHV0U3RyZWFtLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxldmVsID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLmxldmVsID49IDApIHtcbiAgICBvcHRpb25zLnpsaWIubGV2ZWwgPSBvcHRpb25zLmxldmVsO1xuICAgIGRlbGV0ZSBvcHRpb25zLmxldmVsO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLmZvcmNlWmlwNjQgJiYgdHlwZW9mIG9wdGlvbnMuemxpYi5sZXZlbCA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy56bGliLmxldmVsID09PSAwKSB7XG4gICAgb3B0aW9ucy5zdG9yZSA9IHRydWU7XG4gIH1cblxuICBvcHRpb25zLm5hbWVQcmVwZW5kU2xhc2ggPSBvcHRpb25zLm5hbWVQcmVwZW5kU2xhc2ggfHwgZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMuY29tbWVudCAmJiBvcHRpb25zLmNvbW1lbnQubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuc2V0Q29tbWVudChvcHRpb25zLmNvbW1lbnQpO1xuICB9XG59O1xuXG5pbmhlcml0cyhaaXBTdHJlYW0sIFppcEFyY2hpdmVPdXRwdXRTdHJlYW0pO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgZW50cnkgZGF0YSB3aXRoIGZhbGxiYWNrcyBmb3Iga2V5IHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5aaXBTdHJlYW0ucHJvdG90eXBlLl9ub3JtYWxpemVGaWxlRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGF0YSA9IHV0aWwuZGVmYXVsdHMoZGF0YSwge1xuICAgIHR5cGU6ICdmaWxlJyxcbiAgICBuYW1lOiBudWxsLFxuICAgIG5hbWVQcmVwZW5kU2xhc2g6IHRoaXMub3B0aW9ucy5uYW1lUHJlcGVuZFNsYXNoLFxuICAgIGxpbmtuYW1lOiBudWxsLFxuICAgIGRhdGU6IG51bGwsXG4gICAgbW9kZTogbnVsbCxcbiAgICBzdG9yZTogdGhpcy5vcHRpb25zLnN0b3JlLFxuICAgIGNvbW1lbnQ6ICcnXG4gIH0pO1xuXG4gIHZhciBpc0RpciA9IGRhdGEudHlwZSA9PT0gJ2RpcmVjdG9yeSc7XG4gIHZhciBpc1N5bWxpbmsgPSBkYXRhLnR5cGUgPT09ICdzeW1saW5rJztcblxuICBpZiAoZGF0YS5uYW1lKSB7XG4gICAgZGF0YS5uYW1lID0gdXRpbC5zYW5pdGl6ZVBhdGgoZGF0YS5uYW1lKTtcblxuICAgIGlmICghaXNTeW1saW5rICYmIGRhdGEubmFtZS5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgaXNEaXIgPSB0cnVlO1xuICAgICAgZGF0YS50eXBlID0gJ2RpcmVjdG9yeSc7XG4gICAgfSBlbHNlIGlmIChpc0Rpcikge1xuICAgICAgZGF0YS5uYW1lICs9ICcvJztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEaXIgfHwgaXNTeW1saW5rKSB7XG4gICAgZGF0YS5zdG9yZSA9IHRydWU7XG4gIH1cblxuICBkYXRhLmRhdGUgPSB1dGlsLmRhdGVpZnkoZGF0YS5kYXRlKTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhbiBlbnRyeSBnaXZlbiBhbiBpbnB1dCBzb3VyY2UgKHRleHQgc3RyaW5nLCBidWZmZXIsIG9yIHN0cmVhbSkuXG4gKlxuICogQHBhcmFtICB7KEJ1ZmZlcnxTdHJlYW18U3RyaW5nKX0gc291cmNlIFRoZSBpbnB1dCBzb3VyY2UuXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSAge1N0cmluZ30gZGF0YS5uYW1lIFNldHMgdGhlIGVudHJ5IG5hbWUgaW5jbHVkaW5nIGludGVybmFsIHBhdGguXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtkYXRhLmNvbW1lbnRdIFNldHMgdGhlIGVudHJ5IGNvbW1lbnQuXG4gKiBAcGFyYW0gIHsoU3RyaW5nfERhdGUpfSBbZGF0YS5kYXRlPU5PVygpXSBTZXRzIHRoZSBlbnRyeSBkYXRlLlxuICogQHBhcmFtICB7TnVtYmVyfSBbZGF0YS5tb2RlPUQ6MDc1NS9GOjA2NDRdIFNldHMgdGhlIGVudHJ5IHBlcm1pc3Npb25zLlxuICogQHBhcmFtICB7Qm9vbGVhbn0gW2RhdGEuc3RvcmU9b3B0aW9ucy5zdG9yZV0gU2V0cyB0aGUgY29tcHJlc3Npb24gbWV0aG9kIHRvIFNUT1JFLlxuICogQHBhcmFtICB7U3RyaW5nfSBbZGF0YS50eXBlPWZpbGVdIFNldHMgdGhlIGVudHJ5IHR5cGUuIERlZmF1bHRzIHRvIGBkaXJlY3RvcnlgXG4gKiBpZiBuYW1lIGVuZHMgd2l0aCB0cmFpbGluZyBzbGFzaC5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB0aGlzXG4gKi9cblppcFN0cmVhbS5wcm90b3R5cGUuZW50cnkgPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHRoaXMuX2VtaXRFcnJvckNhbGxiYWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBkYXRhID0gdGhpcy5fbm9ybWFsaXplRmlsZURhdGEoZGF0YSk7XG5cbiAgaWYgKGRhdGEudHlwZSAhPT0gJ2ZpbGUnICYmIGRhdGEudHlwZSAhPT0gJ2RpcmVjdG9yeScgJiYgZGF0YS50eXBlICE9PSAnc3ltbGluaycpIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoZGF0YS50eXBlICsgJyBlbnRyaWVzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YS5uYW1lICE9PSAnc3RyaW5nJyB8fCBkYXRhLm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKCdlbnRyeSBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIHZhbHVlJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkYXRhLnR5cGUgPT09ICdzeW1saW5rJyAmJiB0eXBlb2YgZGF0YS5saW5rbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2VudHJ5IGxpbmtuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIHZhbHVlIHdoZW4gdHlwZSBlcXVhbHMgc3ltbGluaycpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZW50cnkgPSBuZXcgWmlwQXJjaGl2ZUVudHJ5KGRhdGEubmFtZSk7XG4gIGVudHJ5LnNldFRpbWUoZGF0YS5kYXRlLCB0aGlzLm9wdGlvbnMuZm9yY2VMb2NhbFRpbWUpO1xuXG4gIGlmIChkYXRhLm5hbWVQcmVwZW5kU2xhc2gpIHtcbiAgICBlbnRyeS5zZXROYW1lKGRhdGEubmFtZSwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoZGF0YS5zdG9yZSkge1xuICAgIGVudHJ5LnNldE1ldGhvZCgwKTtcbiAgfVxuXG4gIGlmIChkYXRhLmNvbW1lbnQubGVuZ3RoID4gMCkge1xuICAgIGVudHJ5LnNldENvbW1lbnQoZGF0YS5jb21tZW50KTtcbiAgfVxuXG4gIGlmIChkYXRhLnR5cGUgPT09ICdzeW1saW5rJyAmJiB0eXBlb2YgZGF0YS5tb2RlICE9PSAnbnVtYmVyJykge1xuICAgIGRhdGEubW9kZSA9IDQwOTYwOyAvLyAwMTIwMDAwXG4gIH1cblxuICBpZiAodHlwZW9mIGRhdGEubW9kZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoZGF0YS50eXBlID09PSAnc3ltbGluaycpIHtcbiAgICAgIGRhdGEubW9kZSB8PSA0MDk2MDtcbiAgICB9XG5cbiAgICBlbnRyeS5zZXRVbml4TW9kZShkYXRhLm1vZGUpO1xuICB9XG5cbiAgaWYgKGRhdGEudHlwZSA9PT0gJ3N5bWxpbmsnICYmIHR5cGVvZiBkYXRhLmxpbmtuYW1lID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZSA9IEJ1ZmZlci5mcm9tKGRhdGEubGlua25hbWUpO1xuICB9XG5cbiAgcmV0dXJuIFppcEFyY2hpdmVPdXRwdXRTdHJlYW0ucHJvdG90eXBlLmVudHJ5LmNhbGwodGhpcywgZW50cnksIHNvdXJjZSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBGaW5hbGl6ZXMgdGhlIGluc3RhbmNlIGFuZCBwcmV2ZW50cyBmdXJ0aGVyIGFwcGVuZGluZyB0byB0aGUgYXJjaGl2ZVxuICogc3RydWN0dXJlIChxdWV1ZSB3aWxsIGNvbnRpbnVlIHRpbCBkcmFpbmVkKS5cbiAqXG4gKiBAcmV0dXJuIHZvaWRcbiAqL1xuWmlwU3RyZWFtLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZpbmlzaCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG51bWJlciBvZiBieXRlcyB3cml0dGVuIHRvIHRoaXMgc3RyZWFtLlxuICogQGZ1bmN0aW9uIFppcFN0cmVhbSNnZXRCeXRlc1dyaXR0ZW5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cblxuLyoqXG4gKiBDb21wcmVzcyBDb21tb25zIFppcEFyY2hpdmVPdXRwdXRTdHJlYW1cbiAqIEBleHRlcm5hbCBaaXBBcmNoaXZlT3V0cHV0U3RyZWFtXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXJjaGl2ZXJqcy9ub2RlLWNvbXByZXNzLWNvbW1vbnN9XG4gKi9cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/zip-stream/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/file.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zip-stream/node_modules/archiver-utils/file.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * archiver-utils\n *\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\n */\nvar fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/./node_modules/graceful-fs/graceful-fs.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\n\nvar flatten = __webpack_require__(/*! lodash.flatten */ \"(rsc)/./node_modules/lodash.flatten/index.js\");\nvar difference = __webpack_require__(/*! lodash.difference */ \"(rsc)/./node_modules/lodash.difference/index.js\");\nvar union = __webpack_require__(/*! lodash.union */ \"(rsc)/./node_modules/lodash.union/index.js\");\nvar isPlainObject = __webpack_require__(/*! lodash.isplainobject */ \"(rsc)/./node_modules/lodash.isplainobject/index.js\");\n\nvar glob = __webpack_require__(/*! glob */ \"(rsc)/./node_modules/glob/glob.js\");\n\nvar file = module.exports = {};\n\nvar pathSeparatorRe = /[\\/\\\\]/g;\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nvar processPatterns = function(patterns, fn) {\n  // Filepaths to return.\n  var result = [];\n  // Iterate over flattened patterns array.\n  flatten(patterns).forEach(function(pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0;\n    // If the pattern is an exclusion, remove the !\n    if (exclusion) { pattern = pattern.slice(1); }\n    // Find all matching files for this pattern.\n    var matches = fn(pattern);\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = union(result, matches);\n    }\n  });\n  return result;\n};\n\n// True if the file path exists.\nfile.exists = function() {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nfile.expand = function(...args) {\n  // If the first argument is an options object, save those options to pass\n  // into the File.prototype.glob.sync method.\n  var options = isPlainObject(args[0]) ? args.shift() : {};\n  // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0) { return []; }\n  // Return all matching filepaths.\n  var matches = processPatterns(patterns, function(pattern) {\n    // Find all matching files for this pattern.\n    return glob.sync(pattern, options);\n  });\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function(filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch(e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\n// Build a multi task \"files\" object dynamically.\nfile.expandMapping = function(patterns, destBase, options) {\n  options = Object.assign({\n    rename: function(destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  }, options);\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  file.expand(options, patterns).forEach(function(src) {\n    var destPath = src;\n    // Flatten?\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    }\n    // Change the extension?\n    if (options.ext) {\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\n    }\n    // Generate destination filename.\n    var dest = options.rename(destBase, destPath, options);\n    // Prepend cwd to src path if necessary.\n    if (options.cwd) { src = path.join(options.cwd, src); }\n    // Normalize filepaths to be unix-style.\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/');\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest,\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// reusing bits of grunt's multi-task source normalization\nfile.normalizeFilesArray = function(data) {\n  var files = [];\n\n  data.forEach(function(obj) {\n    var prop;\n    if ('src' in obj || 'dest' in obj) {\n      files.push(obj);\n    }\n  });\n\n  if (files.length === 0) {\n    return [];\n  }\n\n  files = _(files).chain().forEach(function(obj) {\n    if (!('src' in obj) || !obj.src) { return; }\n    // Normalize .src properties to flattened array.\n    if (Array.isArray(obj.src)) {\n      obj.src = flatten(obj.src);\n    } else {\n      obj.src = [obj.src];\n    }\n  }).map(function(obj) {\n    // Build options object, removing unwanted properties.\n    var expandOptions = Object.assign({}, obj);\n    delete expandOptions.src;\n    delete expandOptions.dest;\n\n    // Expand file mappings.\n    if (obj.expand) {\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\n        // Copy obj properties to result.\n        var result = Object.assign({}, obj);\n        // Make a clone of the orig obj available.\n        result.orig = Object.assign({}, obj);\n        // Set .src and .dest, processing both as templates.\n        result.src = mapObj.src;\n        result.dest = mapObj.dest;\n        // Remove unwanted properties.\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {\n          delete result[prop];\n        });\n        return result;\n      });\n    }\n\n    // Copy obj properties to result, adding an .orig property.\n    var result = Object.assign({}, obj);\n    // Make a clone of the orig obj available.\n    result.orig = Object.assign({}, obj);\n\n    if ('src' in result) {\n      // Expose an expand-on-demand getter method as .src.\n      Object.defineProperty(result, 'src', {\n        enumerable: true,\n        get: function fn() {\n          var src;\n          if (!('result' in fn)) {\n            src = obj.src;\n            // If src is an array, flatten it. Otherwise, make it into an array.\n            src = Array.isArray(src) ? flatten(src) : [src];\n            // Expand src files, memoizing result.\n            fn.result = file.expand(expandOptions, src);\n          }\n          return fn.result;\n        }\n      });\n    }\n\n    if ('dest' in result) {\n      result.dest = obj.dest;\n    }\n\n    return result;\n  }).flatten().value();\n\n  return files;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvemlwLXN0cmVhbS9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxvRUFBYTtBQUM5QixXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCLGNBQWMsbUJBQU8sQ0FBQyxvRUFBZ0I7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsMEVBQW1CO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxnRUFBYztBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBc0I7O0FBRWxELFdBQVcsbUJBQU8sQ0FBQywrQ0FBTTs7QUFFekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkIGdva3VsXFxEb3dubG9hZHNcXHFybWFuYWdlbWVudFxcbm9kZV9tb2R1bGVzXFx6aXAtc3RyZWFtXFxub2RlX21vZHVsZXNcXGFyY2hpdmVyLXV0aWxzXFxmaWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogYXJjaGl2ZXItdXRpbHNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCBDaHJpcyBUYWxraW5ndG9uLCBjb250cmlidXRvcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJjaGl2ZXJqcy9ub2RlLWFyY2hpdmVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UtTUlUXG4gKi9cbnZhciBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxudmFyIGZsYXR0ZW4gPSByZXF1aXJlKCdsb2Rhc2guZmxhdHRlbicpO1xudmFyIGRpZmZlcmVuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGlmZmVyZW5jZScpO1xudmFyIHVuaW9uID0gcmVxdWlyZSgnbG9kYXNoLnVuaW9uJyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC5pc3BsYWlub2JqZWN0Jyk7XG5cbnZhciBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xuXG52YXIgZmlsZSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBwYXRoU2VwYXJhdG9yUmUgPSAvW1xcL1xcXFxdL2c7XG5cbi8vIFByb2Nlc3Mgc3BlY2lmaWVkIHdpbGRjYXJkIGdsb2IgcGF0dGVybnMgb3IgZmlsZW5hbWVzIGFnYWluc3QgYVxuLy8gY2FsbGJhY2ssIGV4Y2x1ZGluZyBhbmQgdW5pcXVpbmcgZmlsZXMgaW4gdGhlIHJlc3VsdCBzZXQuXG52YXIgcHJvY2Vzc1BhdHRlcm5zID0gZnVuY3Rpb24ocGF0dGVybnMsIGZuKSB7XG4gIC8vIEZpbGVwYXRocyB0byByZXR1cm4uXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgLy8gSXRlcmF0ZSBvdmVyIGZsYXR0ZW5lZCBwYXR0ZXJucyBhcnJheS5cbiAgZmxhdHRlbihwYXR0ZXJucykuZm9yRWFjaChmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgLy8gSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyAhIGl0IHNob3VsZCBiZSBvbWl0dGVkXG4gICAgdmFyIGV4Y2x1c2lvbiA9IHBhdHRlcm4uaW5kZXhPZignIScpID09PSAwO1xuICAgIC8vIElmIHRoZSBwYXR0ZXJuIGlzIGFuIGV4Y2x1c2lvbiwgcmVtb3ZlIHRoZSAhXG4gICAgaWYgKGV4Y2x1c2lvbikgeyBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxKTsgfVxuICAgIC8vIEZpbmQgYWxsIG1hdGNoaW5nIGZpbGVzIGZvciB0aGlzIHBhdHRlcm4uXG4gICAgdmFyIG1hdGNoZXMgPSBmbihwYXR0ZXJuKTtcbiAgICBpZiAoZXhjbHVzaW9uKSB7XG4gICAgICAvLyBJZiBhbiBleGNsdXNpb24sIHJlbW92ZSBtYXRjaGluZyBmaWxlcy5cbiAgICAgIHJlc3VsdCA9IGRpZmZlcmVuY2UocmVzdWx0LCBtYXRjaGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBtYXRjaGluZyBmaWxlcy5cbiAgICAgIHJlc3VsdCA9IHVuaW9uKHJlc3VsdCwgbWF0Y2hlcyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIFRydWUgaWYgdGhlIGZpbGUgcGF0aCBleGlzdHMuXG5maWxlLmV4aXN0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsZXBhdGggPSBwYXRoLmpvaW4uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIGZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpO1xufTtcblxuLy8gUmV0dXJuIGFuIGFycmF5IG9mIGFsbCBmaWxlIHBhdGhzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHdpbGRjYXJkIHBhdHRlcm5zLlxuZmlsZS5leHBhbmQgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvcHRpb25zIG9iamVjdCwgc2F2ZSB0aG9zZSBvcHRpb25zIHRvIHBhc3NcbiAgLy8gaW50byB0aGUgRmlsZS5wcm90b3R5cGUuZ2xvYi5zeW5jIG1ldGhvZC5cbiAgdmFyIG9wdGlvbnMgPSBpc1BsYWluT2JqZWN0KGFyZ3NbMF0pID8gYXJncy5zaGlmdCgpIDoge307XG4gIC8vIFVzZSB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQncyBhbiBBcnJheSwgb3RoZXJ3aXNlIGNvbnZlcnQgdGhlIGFyZ3VtZW50c1xuICAvLyBvYmplY3QgdG8gYW4gYXJyYXkgYW5kIHVzZSB0aGF0LlxuICB2YXIgcGF0dGVybnMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gIC8vIFJldHVybiBlbXB0eSBzZXQgaWYgdGhlcmUgYXJlIG5vIHBhdHRlcm5zIG9yIGZpbGVwYXRocy5cbiAgaWYgKHBhdHRlcm5zLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgLy8gUmV0dXJuIGFsbCBtYXRjaGluZyBmaWxlcGF0aHMuXG4gIHZhciBtYXRjaGVzID0gcHJvY2Vzc1BhdHRlcm5zKHBhdHRlcm5zLCBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgLy8gRmluZCBhbGwgbWF0Y2hpbmcgZmlsZXMgZm9yIHRoaXMgcGF0dGVybi5cbiAgICByZXR1cm4gZ2xvYi5zeW5jKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB9KTtcbiAgLy8gRmlsdGVyIHJlc3VsdCBzZXQ/XG4gIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgIG1hdGNoZXMgPSBtYXRjaGVzLmZpbHRlcihmdW5jdGlvbihmaWxlcGF0aCkge1xuICAgICAgZmlsZXBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5jd2QgfHwgJycsIGZpbGVwYXRoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5maWx0ZXIoZmlsZXBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZSBmaWxlIGlzIG9mIHRoZSByaWdodCB0eXBlIGFuZCBleGlzdHMsIHRoaXMgc2hvdWxkIHdvcmsuXG4gICAgICAgICAgcmV0dXJuIGZzLnN0YXRTeW5jKGZpbGVwYXRoKVtvcHRpb25zLmZpbHRlcl0oKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQncyBwcm9iYWJseSBub3QgdGhlIHJpZ2h0IHR5cGUuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbi8vIEJ1aWxkIGEgbXVsdGkgdGFzayBcImZpbGVzXCIgb2JqZWN0IGR5bmFtaWNhbGx5LlxuZmlsZS5leHBhbmRNYXBwaW5nID0gZnVuY3Rpb24ocGF0dGVybnMsIGRlc3RCYXNlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICByZW5hbWU6IGZ1bmN0aW9uKGRlc3RCYXNlLCBkZXN0UGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguam9pbihkZXN0QmFzZSB8fCAnJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgfSwgb3B0aW9ucyk7XG4gIHZhciBmaWxlcyA9IFtdO1xuICB2YXIgZmlsZUJ5RGVzdCA9IHt9O1xuICAvLyBGaW5kIGFsbCBmaWxlcyBtYXRjaGluZyBwYXR0ZXJuLCB1c2luZyBwYXNzZWQtaW4gb3B0aW9ucy5cbiAgZmlsZS5leHBhbmQob3B0aW9ucywgcGF0dGVybnMpLmZvckVhY2goZnVuY3Rpb24oc3JjKSB7XG4gICAgdmFyIGRlc3RQYXRoID0gc3JjO1xuICAgIC8vIEZsYXR0ZW4/XG4gICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgZGVzdFBhdGggPSBwYXRoLmJhc2VuYW1lKGRlc3RQYXRoKTtcbiAgICB9XG4gICAgLy8gQ2hhbmdlIHRoZSBleHRlbnNpb24/XG4gICAgaWYgKG9wdGlvbnMuZXh0KSB7XG4gICAgICBkZXN0UGF0aCA9IGRlc3RQYXRoLnJlcGxhY2UoLyhcXC5bXlxcL10qKT8kLywgb3B0aW9ucy5leHQpO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBkZXN0aW5hdGlvbiBmaWxlbmFtZS5cbiAgICB2YXIgZGVzdCA9IG9wdGlvbnMucmVuYW1lKGRlc3RCYXNlLCBkZXN0UGF0aCwgb3B0aW9ucyk7XG4gICAgLy8gUHJlcGVuZCBjd2QgdG8gc3JjIHBhdGggaWYgbmVjZXNzYXJ5LlxuICAgIGlmIChvcHRpb25zLmN3ZCkgeyBzcmMgPSBwYXRoLmpvaW4ob3B0aW9ucy5jd2QsIHNyYyk7IH1cbiAgICAvLyBOb3JtYWxpemUgZmlsZXBhdGhzIHRvIGJlIHVuaXgtc3R5bGUuXG4gICAgZGVzdCA9IGRlc3QucmVwbGFjZShwYXRoU2VwYXJhdG9yUmUsICcvJyk7XG4gICAgc3JjID0gc3JjLnJlcGxhY2UocGF0aFNlcGFyYXRvclJlLCAnLycpO1xuICAgIC8vIE1hcCBjb3JyZWN0IHNyYyBwYXRoIHRvIGRlc3QgcGF0aC5cbiAgICBpZiAoZmlsZUJ5RGVzdFtkZXN0XSkge1xuICAgICAgLy8gSWYgZGVzdCBhbHJlYWR5IGV4aXN0cywgcHVzaCB0aGlzIHNyYyBvbnRvIHRoYXQgZGVzdCdzIHNyYyBhcnJheS5cbiAgICAgIGZpbGVCeURlc3RbZGVzdF0uc3JjLnB1c2goc3JjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBzcmMtZGVzdCBmaWxlIG1hcHBpbmcgb2JqZWN0LlxuICAgICAgZmlsZXMucHVzaCh7XG4gICAgICAgIHNyYzogW3NyY10sXG4gICAgICAgIGRlc3Q6IGRlc3QsXG4gICAgICB9KTtcbiAgICAgIC8vIEFuZCBzdG9yZSBhIHJlZmVyZW5jZSBmb3IgbGF0ZXIgdXNlLlxuICAgICAgZmlsZUJ5RGVzdFtkZXN0XSA9IGZpbGVzW2ZpbGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmaWxlcztcbn07XG5cbi8vIHJldXNpbmcgYml0cyBvZiBncnVudCdzIG11bHRpLXRhc2sgc291cmNlIG5vcm1hbGl6YXRpb25cbmZpbGUubm9ybWFsaXplRmlsZXNBcnJheSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGZpbGVzID0gW107XG5cbiAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBwcm9wO1xuICAgIGlmICgnc3JjJyBpbiBvYmogfHwgJ2Rlc3QnIGluIG9iaikge1xuICAgICAgZmlsZXMucHVzaChvYmopO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGZpbGVzID0gXyhmaWxlcykuY2hhaW4oKS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghKCdzcmMnIGluIG9iaikgfHwgIW9iai5zcmMpIHsgcmV0dXJuOyB9XG4gICAgLy8gTm9ybWFsaXplIC5zcmMgcHJvcGVydGllcyB0byBmbGF0dGVuZWQgYXJyYXkuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLnNyYykpIHtcbiAgICAgIG9iai5zcmMgPSBmbGF0dGVuKG9iai5zcmMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmouc3JjID0gW29iai5zcmNdO1xuICAgIH1cbiAgfSkubWFwKGZ1bmN0aW9uKG9iaikge1xuICAgIC8vIEJ1aWxkIG9wdGlvbnMgb2JqZWN0LCByZW1vdmluZyB1bndhbnRlZCBwcm9wZXJ0aWVzLlxuICAgIHZhciBleHBhbmRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICBkZWxldGUgZXhwYW5kT3B0aW9ucy5zcmM7XG4gICAgZGVsZXRlIGV4cGFuZE9wdGlvbnMuZGVzdDtcblxuICAgIC8vIEV4cGFuZCBmaWxlIG1hcHBpbmdzLlxuICAgIGlmIChvYmouZXhwYW5kKSB7XG4gICAgICByZXR1cm4gZmlsZS5leHBhbmRNYXBwaW5nKG9iai5zcmMsIG9iai5kZXN0LCBleHBhbmRPcHRpb25zKS5tYXAoZnVuY3Rpb24obWFwT2JqKSB7XG4gICAgICAgIC8vIENvcHkgb2JqIHByb3BlcnRpZXMgdG8gcmVzdWx0LlxuICAgICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgLy8gTWFrZSBhIGNsb25lIG9mIHRoZSBvcmlnIG9iaiBhdmFpbGFibGUuXG4gICAgICAgIHJlc3VsdC5vcmlnID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgLy8gU2V0IC5zcmMgYW5kIC5kZXN0LCBwcm9jZXNzaW5nIGJvdGggYXMgdGVtcGxhdGVzLlxuICAgICAgICByZXN1bHQuc3JjID0gbWFwT2JqLnNyYztcbiAgICAgICAgcmVzdWx0LmRlc3QgPSBtYXBPYmouZGVzdDtcbiAgICAgICAgLy8gUmVtb3ZlIHVud2FudGVkIHByb3BlcnRpZXMuXG4gICAgICAgIFsnZXhwYW5kJywgJ2N3ZCcsICdmbGF0dGVuJywgJ3JlbmFtZScsICdleHQnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICBkZWxldGUgcmVzdWx0W3Byb3BdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENvcHkgb2JqIHByb3BlcnRpZXMgdG8gcmVzdWx0LCBhZGRpbmcgYW4gLm9yaWcgcHJvcGVydHkuXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgLy8gTWFrZSBhIGNsb25lIG9mIHRoZSBvcmlnIG9iaiBhdmFpbGFibGUuXG4gICAgcmVzdWx0Lm9yaWcgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuXG4gICAgaWYgKCdzcmMnIGluIHJlc3VsdCkge1xuICAgICAgLy8gRXhwb3NlIGFuIGV4cGFuZC1vbi1kZW1hbmQgZ2V0dGVyIG1ldGhvZCBhcyAuc3JjLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ3NyYycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgICB2YXIgc3JjO1xuICAgICAgICAgIGlmICghKCdyZXN1bHQnIGluIGZuKSkge1xuICAgICAgICAgICAgc3JjID0gb2JqLnNyYztcbiAgICAgICAgICAgIC8vIElmIHNyYyBpcyBhbiBhcnJheSwgZmxhdHRlbiBpdC4gT3RoZXJ3aXNlLCBtYWtlIGl0IGludG8gYW4gYXJyYXkuXG4gICAgICAgICAgICBzcmMgPSBBcnJheS5pc0FycmF5KHNyYykgPyBmbGF0dGVuKHNyYykgOiBbc3JjXTtcbiAgICAgICAgICAgIC8vIEV4cGFuZCBzcmMgZmlsZXMsIG1lbW9pemluZyByZXN1bHQuXG4gICAgICAgICAgICBmbi5yZXN1bHQgPSBmaWxlLmV4cGFuZChleHBhbmRPcHRpb25zLCBzcmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm4ucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoJ2Rlc3QnIGluIHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRlc3QgPSBvYmouZGVzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KS5mbGF0dGVuKCkudmFsdWUoKTtcblxuICByZXR1cm4gZmlsZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/zip-stream/node_modules/archiver-utils/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * archiver-utils\n *\n * Copyright (c) 2015 Chris Talkington.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE\n */\nvar fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/./node_modules/graceful-fs/graceful-fs.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar lazystream = __webpack_require__(/*! lazystream */ \"(rsc)/./node_modules/lazystream/lib/lazystream.js\");\nvar normalizePath = __webpack_require__(/*! normalize-path */ \"(rsc)/./node_modules/normalize-path/index.js\");\nvar defaults = __webpack_require__(/*! lodash.defaults */ \"(rsc)/./node_modules/lodash.defaults/index.js\");\n\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\nvar PassThrough = (__webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\").PassThrough);\n\nvar utils = module.exports = {};\nutils.file = __webpack_require__(/*! ./file.js */ \"(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/file.js\");\n\nutils.collectStream = function(source, callback) {\n  var collection = [];\n  var size = 0;\n\n  source.on('error', callback);\n\n  source.on('data', function(chunk) {\n    collection.push(chunk);\n    size += chunk.length;\n  });\n\n  source.on('end', function() {\n    var buf = Buffer.alloc(size);\n    var offset = 0;\n\n    collection.forEach(function(data) {\n      data.copy(buf, offset);\n      offset += data.length;\n    });\n\n    callback(null, buf);\n  });\n};\n\nutils.dateify = function(dateish) {\n  dateish = dateish || new Date();\n\n  if (dateish instanceof Date) {\n    dateish = dateish;\n  } else if (typeof dateish === 'string') {\n    dateish = new Date(dateish);\n  } else {\n    dateish = new Date();\n  }\n\n  return dateish;\n};\n\n// this is slightly different from lodash version\nutils.defaults = function(object, source, guard) {\n  var args = arguments;\n  args[0] = args[0] || {};\n\n  return defaults(...args);\n};\n\nutils.isStream = function(source) {\n  return source instanceof Stream;\n};\n\nutils.lazyReadStream = function(filepath) {\n  return new lazystream.Readable(function() {\n    return fs.createReadStream(filepath);\n  });\n};\n\nutils.normalizeInputSource = function(source) {\n  if (source === null) {\n    return Buffer.alloc(0);\n  } else if (typeof source === 'string') {\n    return Buffer.from(source);\n  } else if (utils.isStream(source)) {\n    // Always pipe through a PassThrough stream to guarantee pausing the stream if it's already flowing,\n    // since it will only be processed in a (distant) future iteration of the event loop, and will lose\n    // data if already flowing now.\n    return source.pipe(new PassThrough());\n  }\n\n  return source;\n};\n\nutils.sanitizePath = function(filepath) {\n  return normalizePath(filepath, false).replace(/^\\w+:/, '').replace(/^(\\.\\.\\/|\\/)+/, '');\n};\n\nutils.trailingSlashIt = function(str) {\n  return str.slice(-1) !== '/' ? str + '/' : str;\n};\n\nutils.unixifyPath = function(filepath) {\n  return normalizePath(filepath, false).replace(/^\\w+:/, '');\n};\n\nutils.walkdir = function(dirpath, base, callback) {\n  var results = [];\n\n  if (typeof base === 'function') {\n    callback = base;\n    base = dirpath;\n  }\n\n  fs.readdir(dirpath, function(err, list) {\n    var i = 0;\n    var file;\n    var filepath;\n\n    if (err) {\n      return callback(err);\n    }\n\n    (function next() {\n      file = list[i++];\n\n      if (!file) {\n        return callback(null, results);\n      }\n\n      filepath = path.join(dirpath, file);\n\n      fs.stat(filepath, function(err, stats) {\n        results.push({\n          path: filepath,\n          relative: path.relative(base, filepath).replace(/\\\\/g, '/'),\n          stats: stats\n        });\n\n        if (stats && stats.isDirectory()) {\n          utils.walkdir(filepath, base, function(err, res) {\n            res.forEach(function(dirEntry) {\n              results.push(dirEntry);\n            });\n            next();\n          });\n        } else {\n          next();\n        }\n      });\n    })();\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvemlwLXN0cmVhbS9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsb0VBQWE7QUFDOUIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFZO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLG9FQUFnQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsc0VBQWlCOztBQUV4QyxhQUFhLG9EQUF3QjtBQUNyQyxrQkFBa0IsNEdBQXNDOztBQUV4RDtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzRkFBVzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGQgZ29rdWxcXERvd25sb2Fkc1xccXJtYW5hZ2VtZW50XFxub2RlX21vZHVsZXNcXHppcC1zdHJlYW1cXG5vZGVfbW9kdWxlc1xcYXJjaGl2ZXItdXRpbHNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogYXJjaGl2ZXItdXRpbHNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2hyaXMgVGFsa2luZ3Rvbi5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL2FyY2hpdmVyLXV0aWxzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xudmFyIGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGxhenlzdHJlYW0gPSByZXF1aXJlKCdsYXp5c3RyZWFtJyk7XG52YXIgbm9ybWFsaXplUGF0aCA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1wYXRoJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCdsb2Rhc2guZGVmYXVsdHMnKTtcblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlBhc3NUaHJvdWdoO1xuXG52YXIgdXRpbHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudXRpbHMuZmlsZSA9IHJlcXVpcmUoJy4vZmlsZS5qcycpO1xuXG51dGlscy5jb2xsZWN0U3RyZWFtID0gZnVuY3Rpb24oc291cmNlLCBjYWxsYmFjaykge1xuICB2YXIgY29sbGVjdGlvbiA9IFtdO1xuICB2YXIgc2l6ZSA9IDA7XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcblxuICBzb3VyY2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGNvbGxlY3Rpb24ucHVzaChjaHVuayk7XG4gICAgc2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gIH0pO1xuXG4gIHNvdXJjZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICBkYXRhLmNvcHkoYnVmLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGRhdGEubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgY2FsbGJhY2sobnVsbCwgYnVmKTtcbiAgfSk7XG59O1xuXG51dGlscy5kYXRlaWZ5ID0gZnVuY3Rpb24oZGF0ZWlzaCkge1xuICBkYXRlaXNoID0gZGF0ZWlzaCB8fCBuZXcgRGF0ZSgpO1xuXG4gIGlmIChkYXRlaXNoIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIGRhdGVpc2ggPSBkYXRlaXNoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRlaXNoID09PSAnc3RyaW5nJykge1xuICAgIGRhdGVpc2ggPSBuZXcgRGF0ZShkYXRlaXNoKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRlaXNoID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIHJldHVybiBkYXRlaXNoO1xufTtcblxuLy8gdGhpcyBpcyBzbGlnaHRseSBkaWZmZXJlbnQgZnJvbSBsb2Rhc2ggdmVyc2lvblxudXRpbHMuZGVmYXVsdHMgPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIGFyZ3NbMF0gPSBhcmdzWzBdIHx8IHt9O1xuXG4gIHJldHVybiBkZWZhdWx0cyguLi5hcmdzKTtcbn07XG5cbnV0aWxzLmlzU3RyZWFtID0gZnVuY3Rpb24oc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBTdHJlYW07XG59O1xuXG51dGlscy5sYXp5UmVhZFN0cmVhbSA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gIHJldHVybiBuZXcgbGF6eXN0cmVhbS5SZWFkYWJsZShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlcGF0aCk7XG4gIH0pO1xufTtcblxudXRpbHMubm9ybWFsaXplSW5wdXRTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc291cmNlKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1N0cmVhbShzb3VyY2UpKSB7XG4gICAgLy8gQWx3YXlzIHBpcGUgdGhyb3VnaCBhIFBhc3NUaHJvdWdoIHN0cmVhbSB0byBndWFyYW50ZWUgcGF1c2luZyB0aGUgc3RyZWFtIGlmIGl0J3MgYWxyZWFkeSBmbG93aW5nLFxuICAgIC8vIHNpbmNlIGl0IHdpbGwgb25seSBiZSBwcm9jZXNzZWQgaW4gYSAoZGlzdGFudCkgZnV0dXJlIGl0ZXJhdGlvbiBvZiB0aGUgZXZlbnQgbG9vcCwgYW5kIHdpbGwgbG9zZVxuICAgIC8vIGRhdGEgaWYgYWxyZWFkeSBmbG93aW5nIG5vdy5cbiAgICByZXR1cm4gc291cmNlLnBpcGUobmV3IFBhc3NUaHJvdWdoKCkpO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZTtcbn07XG5cbnV0aWxzLnNhbml0aXplUGF0aCA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gIHJldHVybiBub3JtYWxpemVQYXRoKGZpbGVwYXRoLCBmYWxzZSkucmVwbGFjZSgvXlxcdys6LywgJycpLnJlcGxhY2UoL14oXFwuXFwuXFwvfFxcLykrLywgJycpO1xufTtcblxudXRpbHMudHJhaWxpbmdTbGFzaEl0ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIuc2xpY2UoLTEpICE9PSAnLycgPyBzdHIgKyAnLycgOiBzdHI7XG59O1xuXG51dGlscy51bml4aWZ5UGF0aCA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gIHJldHVybiBub3JtYWxpemVQYXRoKGZpbGVwYXRoLCBmYWxzZSkucmVwbGFjZSgvXlxcdys6LywgJycpO1xufTtcblxudXRpbHMud2Fsa2RpciA9IGZ1bmN0aW9uKGRpcnBhdGgsIGJhc2UsIGNhbGxiYWNrKSB7XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgaWYgKHR5cGVvZiBiYXNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiYXNlO1xuICAgIGJhc2UgPSBkaXJwYXRoO1xuICB9XG5cbiAgZnMucmVhZGRpcihkaXJwYXRoLCBmdW5jdGlvbihlcnIsIGxpc3QpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGZpbGU7XG4gICAgdmFyIGZpbGVwYXRoO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgKGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBmaWxlID0gbGlzdFtpKytdO1xuXG4gICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgfVxuXG4gICAgICBmaWxlcGF0aCA9IHBhdGguam9pbihkaXJwYXRoLCBmaWxlKTtcblxuICAgICAgZnMuc3RhdChmaWxlcGF0aCwgZnVuY3Rpb24oZXJyLCBzdGF0cykge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgICAgIHJlbGF0aXZlOiBwYXRoLnJlbGF0aXZlKGJhc2UsIGZpbGVwYXRoKS5yZXBsYWNlKC9cXFxcL2csICcvJyksXG4gICAgICAgICAgc3RhdHM6IHN0YXRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgdXRpbHMud2Fsa2RpcihmaWxlcGF0aCwgYmFzZSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uKGRpckVudHJ5KSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkaXJFbnRyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/zip-stream/node_modules/archiver-utils/index.js\n");

/***/ })

};
;